# Encoding: UTF-8
grammar EDNGRAMMAR
rule seq
(S (item S ("," S item S)* OC)? S) {
  def ast
    r = if e = elements[1].elements
          [e[0].ast] + e[2].elements.map {|x| x.item.ast }
        else
          []
        end
    if r.size == 1
      r.first
    else
      CBOR::Sequence.new(r)
    end
  end
}
end
rule item
(map / array / tagged / number / simple / string / streamstring)
end
rule number
((basenumber / decnumber / infin) spec) {
  def ast
    elements[0].ast
  end
}
end
rule string
((tstr / bstr) spec) {
  def ast
    elements[0].ast
  end
}
end
rule sign
("+" / "-")
end
rule decnumber
(sign? DIGIT+ ("." DIGIT+)? ("e"i sign? DIGIT+)?) {
  def ast
    ip = elements[0].text_value + elements[1].text_value
    dp = elements[2].text_value
    ep = elements[3].text_value
    if dp.empty? && ep.empty?
      ip.to_i
    else
      (ip + dp + ep).to_f
    end
  end
}
end
rule basenumber
(sign? "0" (("x"i HEXDIG+ (("." HEXDIG+)? "p"i sign? DIGIT*)?) / ("o"i ODIGIT+) / ("b"i BDIGIT+))) {
  def ast; /p/i =~ text_value ? Float(text_value) : Integer(text_value) end
}
end
rule infin
("Infinity" { def ast; Float::INFINITY end } / "-Infinity" { def ast; -Float::INFINITY end } / "NaN" { def ast; Float::NAN end })
end
rule simple
("false" { def ast; false end } / "true" { def ast; true end } / "null" { def ast; nil end } / "undefined" { def ast; CBOR::Simple.new(23) end } / ("simple(" S item S ")") {
                  def ast; CBOR::Simple.new(item.ast) end
                })
end
rule uint
("0" / (DIGIT1 DIGIT*))
end
rule tagged
(uint spec "(" S item S ")") {
  def ast
    CBOR::Tagged.new(uint.text_value.to_i, item.ast)
  end
}
end
rule app_prefix
(lcalpha lcalnum*)
end
rule app_string
(app_prefix sqstr) {
  def ast                       # XXX ignoring h and b64
    data = sqstr.ast.force_encoding(Encoding::UTF_8) # XXX undo .b
    app = app_prefix.text_value
    # Find a better place to put a default initialization
    EDNGRAMMAR.const_set(:APPS, Hash.new { |h, k|
                           h[k] = begin ::CBOR_DIAG.const_get("App_#{app}")
                                  rescue NameError
                                    raise ArgumentError, "cbor-diagnostic: Unknown application-oriented extension '#{k}'", caller
                                  end
                         }) unless ::EDNGRAMMAR.const_defined?(:APPS)
    ::EDNGRAMMAR::APPS[app].decode(app, data)
  end
}
end
rule sqstr
("'" single_quoted* "'") {
  def ast
    elements[1].elements.map {|x| x.ast}.join.b # XXX .b
  end
}
end
rule bstr
(app_string / sqstr / embedded)
end
rule tstr
(DQUOTE double_quoted* DQUOTE) {
  def ast
    elements[1].elements.map {|x| x.ast}.join
  end
}
end
rule embedded
("<<" seq ">>") {
  def ast
    sn = seq.ast
    if CBOR::Sequence === sn
      sn.to_cborseq
    else
      CBOR.encode(sn)
    end
  end
}
end
rule array
("[" spec (item S ("," S item S)* OC)? "]") {
  def ast
    r = if e = elements[2].elements
          [e[0].ast] + e[2].elements.map {|x| x.item.ast }
        else
          []
        end
    if ei = spec.ast
       if ei == ""
         r.cbor_stream!
       else
         warn "*** ignoring unimplemented encoding indicator #{ei.inspect} after ["
       end
    end
    r
  end
}
end
rule map
("{" spec (kp S ("," S kp S)* OC)? "}") {
  def ast
    r = if e = elements[2].elements
          Hash[ [e[0].ast] + e[2].elements.map {|x| x.kp.ast } ]
        else
          {}
        end
    if ei = spec.ast
       if ei == ""
         r.cbor_stream!
       else
         warn "*** ignoring unimplemented encoding indicator #{ei.inspect} after \x7b"
       end
    end
    r
  end
}
end
rule kp
(item S ":" S item) {
  def ast
    [elements[0].ast, elements[4].ast]
  end
}
end
rule blank
("\t" / "\n" / "\r" / " ")
end
rule non_slash
(blank / [!-\.] / [0-퟿] / [-􏿿])
end
rule non_lf
("\t" / "\r" / [\ -퟿] / [-􏿿])
end
rule S
(blank* (comment blank*)*)
end
rule comment
(("/" non_slash* "/") / ("#" non_lf* "\n"))
end
rule OC
("," S)?
end
rule streamstring
("(" spec1 string S ("," S string S)* OC ")") {
  def ast
    strings = [elements[2].ast] + elements[4].elements.map {|x| x.string.ast }
    unless Set[*strings.map(&:encoding)].size == 1
      warn "** mixed streamstring #{strings.cbor_diagnostic}"
    end
    strings.join.cbor_stream!(strings.map(&:size))
  end
}
end
rule spec
("_" wordchar* S)? {def ast;
                    if (e1 = elements[1].elements) && !e1[0].empty?
                      e1[1].text_value
                    end
                  end}
end
rule spec1
("_" S)
end
rule double_quoted
(unescaped {def ast; text_value end} / "'" {def ast; text_value end} / ("\\" DQUOTE) {def ast; elements[1].text_value end} / ("\\" escapable) {def ast; escapable.ast end})
end
rule single_quoted
(unescaped {def ast; text_value end} / DQUOTE {def ast; text_value end} / ("\\" "'") {def ast; elements[1].text_value end} / ("\\" escapable) {def ast; escapable.ast end})
end
rule escapable
("b" {def ast; "\b" end} / "f" {def ast; "\f" end} / "n" {def ast; "\n" end} / "r" {def ast; "\r" end} / "t" {def ast; "\t" end} / "/" {def ast; text_value end} / "\\" {def ast; text_value end} / ("u" hexchar) {def ast; hexchar.ast end})
end
rule hexchar
(non_surrogate {def ast; hex_value.chr(Encoding::UTF_8) end} / (high_surrogate "\\" "u" low_surrogate) {
  def ast
    ((high_surrogate.ast << 10) + low_surrogate.ast + 0x10000).chr(Encoding::UTF_8)
  end
})
end
rule non_surrogate
(((DIGIT / "A"i / "B"i / "C"i / "E"i / "F"i) HEXDIG 3..3) / ("D"i ODIGIT HEXDIG 2..2))
end
rule high_surrogate
("D"i ("8" / "9" / "A"i / "B"i) HEXDIG 2..2) {def ast; hex_value - 0xD800 end}
end
rule low_surrogate
("D"i ("C"i / "D"i / "E"i / "F"i) HEXDIG 2..2) {def ast; hex_value - 0xDC00 end}
end
rule unescaped
("\n" / "\r" / [\ -!] / [\#-&] / [\(-\[] / [\]-퟿] / [-􏿿])
end
rule DQUOTE
"\""
end
rule DIGIT
[0-9]
end
rule DIGIT1
[1-9]
end
rule ODIGIT
[0-7]
end
rule BDIGIT
[0-1]
end
rule HEXDIG
(DIGIT / "A"i / "B"i / "C"i / "D"i / "E"i / "F"i)
end
rule lcalpha
[a-z]
end
rule lcalnum
(lcalpha / DIGIT)
end
rule wordchar
("_" / lcalnum / [A-Z])
end

end
